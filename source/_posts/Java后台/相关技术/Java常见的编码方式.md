---
title: Java常见的编码方式
date: 2017-09-21 20:54:12
categories: server
tags: [Java] 
---
### 计算机为什么要编码
在计算机中所有的数据都是以0,1来存储的,那字符是怎样在计算机存储的呢,美国的科学家把一个特定的数字对应一个特定的字母进行存储和传输，比如我需要存储字母a，那么我存入一个数字97(即在计算机中存入二进制(01100001)，这个过程叫做编码(encode)，而我们在读取数据的时候，当遇到97时，我们就让计算机显示字母a，这个过程叫做解码(decode)。
### 编码发展历史简介

<!--more-->

#### 第一阶段ASCII
规则:


1. 所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。


2. 把所有的标点符号，英文大小写全部放在32-126范围中。


3. 防止以后出现需要补充的情况，把128-255位这么多位置留出来，应该足够用了吧！所以设置一个字节8位二进制，把这个标准叫American Standard Code for Information Interchange(美国标准信息交换代码，简写为ASCII)，标准制定结束。

实现方式:

第一位始终未0，后面7位表示0-127的范围，一个数字对应一个字母或者标点符号，亦或者控制符号，即所有的ASCII码的统一形式为0xxxx xxxx。

#### 第二阶段 GB2312,GBK, BIG5 Latin1, ISO-8859-1, JIS, ANSI...

>计算机技术到了欧洲，欧洲人发现怎么我们的那么多符号没有编进去啊！
所以欧洲"砖家"坐到了一起，开始讨论。
发现既然美国人把第一位流出来了，那么我们就用128-255的位置好了。

规则:

1. 128-159之间为控制字符，160-255位文字符号，其中包括了西欧语言、希腊语、泰语、阿拉伯语、希伯来语。


2. 刚好把美国人给的空间全部用完，世界真美好，谢谢美利坚预留的每一个位置。


3. 砖家们决定把他们的编码名称叫做Latin1，后面由于欧洲统一制定ISO标准，所以又有了一个ISO的名称，即ISO-8859-1。

实现方式:



1. 0-127的所有位置不动，那么可以兼容ASCII，二进制位0xxx xxxx


2. 128-255位置全部用完，二进制位1xxx xxxx
由于所有的位置全部用完，而欧元符号实在指定标准之后才出现的，所以在这个码表中连欧洲人自己的货币符号都没有办法放进去。

>计算机技术当然也传到了亚洲大地，比如中国。
中国砖家们坐在一起发现，美国人搞的这个东西真的有问题，预留才128-255的空间，可是我们的汉字个数远远超出了这个数目啊，怎么办？？
后面聪明的中国砖家们发现，只能使用2个字节了，否则真的搞不定。
由于必须和美国原来制定的ASCII不冲突，所以指定了如下规则

规则:

1. 如果一个字节中第一位为0，那么这就是一个ASCII字符。


2. 如果一个字节中第一位为1，那么这个是汉字，认定需要2个字节才表示一个编码的文字。
把这个码表叫GB2312
这个码表中包含汉字6763个和非汉字图形字符682个。
还有很多的空间没有用到，索性全部预留了吧。

实现方式:


1. 0xxxxxxx：表示为ASCII字符


2. -1xxxxxxx 1xxxxxxx：表示为汉字

后面再次添加更多的字符进去，再次命名为GB18030，兼容GBK。由于汉字很多，2个字节并不能完全包括进去，所以GB18030采用2\4位混编的形式。

当然计算机也传到了日本(JIS)、韩国、台湾(BIG5)等等地方，大家全部发挥自己的聪明才智，各自实现了自己的编码。这些编码都与ASCII兼容，但是相互之间不兼容。

使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为"MBCS（Muilti-Bytes Charecter Set，多字节字符集）"。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 windows下要转码成gb2312,gbk只需要把文本保存为ANSI编码即可。 不同ANSI编码之间互不兼容

#### 第三阶段
>随着通讯越来越多，而老美发现在自己公司需要国际化的时候，自己原来埋的这个雷真的害了自己。
于是乎，开始研讨把世界上几乎所有文字全部放在一个码表中，而这个包罗万象的码表就叫做Unicode，即万国码。
Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。
实际上，在软件制造商的协会（unicode.org）在做这个工作时，国际标准化组织（ISO）在做同样的事情，最后大家都意识到世界上并不需要两个不同的万国码，于是大家坐在一起合并研究的成果，最后的结果就是现在的Unicode。

### 各个编码及其范围
#### ASCII

编码范围00-7F，其中00-1F、FF为控制字符。其它为英文字母、数字、标点符号。

#### Latin1

编码范围00-FF，其中00-7F同ASCII，80-9F为控制符、9F-FF为字母和标点符号.

#### CP1252

微软的企业标准，补充了一些符号和欧元符号，为Latin1的超集。

#### GB2312

编码范围为A1A1-F7FE(剔除xx7F)，共23940个码位。其中很多区间没有用到，而汉字使用的区间为B0A1-F7FE，其他为标点符号和特殊字符。
除常用简体汉字字符外还包括希腊字母、日文平假名及片假名字母、俄语西里尔字母等字符，未收录繁体中文汉字和一些生僻字。
对汉字进行了分区管理，其中第一个字节为区位码，包括下面区位。
01-09区为特殊符号。
16-55区为一级汉字，按拼音排序。
56-87区为二级汉字，按部首/笔画排序。
10-15区及88-94区则未有编码。
第二个字节为位字节，01-94总计94个。
为什么实际选择不是01-5E，而是选择A1-F7的位置呢？
因为英文可见字符区间为20-7F，加上128(也就是最高位为1)后得到的取件即是A1-FE
区位码使用了0xA1-0xF7(把01-87区的区号加上0xA0)，位字节使用了0xA1-0xFE(把01-94加上 0xA0)

#### GBK

编码范围为8140-FEFE,兼容GB2312，仍然有部分区间没有用到。
GBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的 汉字部首符号、竖排标点符号等字符。
GBK对GB2312就是，你有的，我也有，你没得的，我还有！

#### CP936

CP936是微软指定的标准，属于企业标准，和GBK的有些许差别，绝大多数情况下可以把CP936当作GBK的别名。

#### BIG5

Big5是双字节编码，高字节编码范围是0x81-0xFE，低字节编码范围是0x40-0x7E和0xA1-0xFE。和GBK相比，少了低字节是0x80-0xA0的组合。0x8140-0xA0FE是保留区域，用于用户造字区。
Big5收录的汉字只包括繁体汉字，不包括简体汉字，一些生僻的汉字也没有收录。

#### CP950

微软的企业标准，可以理解为是对 Big5的扩展。

#### GB18030

编码范围同GBK，补充了更多的字符，由于Unicode开始流行且GB18030补充的字符都比较生僻，所以实际使用上基本是GBK。
GB18030编码是变长编码，有单字节、双字节和四字节三种方式。GB18030的单字节编码范围是0x00-0x7F，完全等同与ASCII；双字节编码的范围和GBK相同，高字节是0x81-0xFE，低字节的编 码范围是0x40-0x7E和0x80-FE；四字节编码中第一、三字节的编码范围是0x81-0xFE，二、四字节是0x30-0x39。

#### Unicode

中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。
一个蛋疼的问题就是这个区间全部都是文字，中文标点没有包含在其中，中文标点散落在各个位置。详细请看http://blog.chinaunix.net/uid-12348673-id-3335307.html。
一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，详细情况可以参考网址：http://www.cnblogs.com/sosoft/p/3456631.html

#### Unicode的实现方式
>Unicode只是进行了编码，也就是说只是一个码表，至于具体怎么实现，并没有规定。
下面是Unicode的几种实现方法。
##### Unicode UTF-8之间的关系
简单来说：
Unicode 是「字符集」

UTF-8 是「编码规则」

其中：

字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）

编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）

Unicode定义了所有可以用来表示字符的数值集合（称之为Code Point）。UTF-8和UTF-16等UTF标准定义了这些数值和字符的映射关系。

正如名字所示，在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分，例如，在UTF－8和ASCII中，“A”的编码都是0x41. 
UTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。

##### UTF-8 (UCS Transfer Format:Unicode转做某种格式) 

UTF-8以字节为单位对Unicode进行编码。

从Unicode到UTF-8的编码方式如下：  

Unicode编码(16进制)  ║ UTF-8 字节流(二进制)  

000000 - 00007F   ║ 0xxxxxxx  

000080 - 0007FF   ║ 110xxxxx 10xxxxxx  

000800 - 00FFFF   ║ 1110xxxx 10xxxxxx 10xxxxxx  

010000 - 10FFFF   ║ 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

特点:UTF-8的特点是对不同范围的字符使用不同长度的编码

##### UTF-16

在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。而在辅助平面定义的字符，会以代理对（surrogate pair）的形式，以两个2字节的值来储存。
UTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16却无法兼容于ASCII编码。
可以认为UTF-16是下面介绍的UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的是同一的意思。但当引入辅助平面字符后，就称为UTF-16了。现在若有软件声称自己支援UCS-2编码，那其实是暗指它不能支援在UTF-16中超过2bytes的字集。对于小于0x10000的UCS码，UTF-16编码就等于UCS码。
如果一个UTF-16文件没有指定BOM，默认应该是UTF-16BE，但是在Intel x86中却是UTF-16LE。所以在现实世界中有很多的没有指定大小尾的UTF-16却是UTF-16LE。

##### UTF-32

每一个Unicode码位使用恰好32位元。可以粗暴的认为UTF-32和下面要介绍的UCS-4是等同的。

##### UCS-2

采用2个字节，定长的表示每一个字符，所以总计可以表示2^16个字符。

##### UCS-4

UCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行(rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。
group 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。
将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。


转自:http://www.cnblogs.com/jessonluo/p/4800331.html


### 编码检测
到底采用什么编码，如果能检测就好了。专家们也是这么想的，所以专家给每种格式和字节序规定了一些特殊的编码，

这些编码在unicode 中是没有使用的，所以不用担心会冲突。

这个叫做BOM（Byte Order Mark）头。意思是字节序标志头。通过它基本能确定编码格式和字节序。

UTF编码　║　Byte Order Mark 
　　
UTF-8　  ║　EF BB BF 　　

UTF-16LE ║　FF FE 　　

UTF-16BE ║　FE FF 　　

UTF-32LE ║　FF FE 00 00 　　

UTF-32BE ║　00 00 FE FF
所以通过检测文件前面的BOM头，基本能确定编码格式和字节序。
但是这个BOM头只是建议添加，不是强制的，所以不少软件和系统没有添加这个BOM头（所以有些软件格式中有带BOM头

和NoBOM头的选择），这个时候要检测什么格式，就比较麻烦了
当然可以检测，但是不能保证100%准确，只能通过编码范围从概率上来检查，虽然准确度还是比较高，但是不能保证

100%。所以，时常看到检测错误的软件，也不奇怪了。

### UTF-8 与UTF-16的区别

   UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.

   于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定.

   于是UTF-8和UTF-16的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用UTF-8就比UTF-16节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16就占优势了,可以节省很多空间.另外还有个容错问题,等会再讲